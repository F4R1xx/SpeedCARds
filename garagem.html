<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SpeedCards - Garagem</title>
    <link rel="icon" href="./assets/icon.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        /* Variáveis CSS para um tema coeso (mesmas da home.html) */
        :root {
            --primary-red: #E01A4F; /* Um vermelho mais profundo e vibrante */
            --dark-bg: #0A0A0A;
            --medium-dark-bg: #1A1A1A;
            --light-text: #F0F0F0;
            --accent-gray: #333333;
            --border-subtle: rgba(255, 255, 255, 0.08);
            --border-strong: rgba(255, 255, 255, 0.15);
            --border-color: rgba(255, 255, 255, 0.1);
            --glow-effect: 0 0 15px rgba(224, 26, 79, 0.7); /* Brilho vermelho */
            --text-shadow-strong: 0 0 8px rgba(0,0,0,0.8);
        }

        body {
            font-family: 'Roboto', sans-serif;
            background-color: var(--dark-bg);
            background-image: radial-gradient(circle at top right, rgba(224, 26, 79, 0.1), transparent 40%),
                              radial-gradient(circle at bottom left, rgba(224, 26, 79, 0.1), transparent 40%);
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            overflow-x: hidden;
            color: var(--light-text);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .font-orbitron {
            font-family: 'Orbitron', sans-serif;
        }

        /* Efeito de ruído sutil para uma textura mais "gritty" */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAMAAAAp4XiDAAAAUVBMVEUAAAD///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC/INx6AAAAF3RSTlMAAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobI+kKpgAAAFpJREFUeNrtwQEBAAAAgqD+r2zHBxQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgZpQAAQ+E4UIAAAAASUVORK5CYII=') repeat;
            opacity: 0.03; /* Ajuste a opacidade para mais ou menos intensidade */
            pointer-events: none;
            z-index: -1;
        }

        /* Estilo para o painel de vidro do menu (usado por menu.js) */
        .glass-panel {
            background: rgba(26, 26, 26, 0.7); /* Cor de fundo semi-transparente */
            backdrop-filter: blur(10px); /* Efeito de vidro fosco */
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid var(--border-subtle);
            border-radius: 12px; /* Cantos arredondados */
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5); /* Sombra para profundidade */
        }

        .header-panel {
            background: linear-gradient(to bottom, rgba(0, 0, 0, 0.8), rgba(0, 0, 0, 0.6));
            backdrop-filter: blur(15px);
            border-bottom: 1px solid var(--border-strong);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.6);
            padding: 1.5rem 2rem;
        }

        .info-box {
            background: var(--accent-gray);
            border: 1px solid var(--border-subtle);
            border-radius: 8px;
            padding: 0.75rem 1.5rem;
            text-shadow: var(--text-shadow-strong);
            transition: all 0.3s ease-in-out;
            box-shadow: 0 3px 8px rgba(0,0,0,0.4);
            position: relative;
            overflow: hidden;
        }
        .info-box:hover {
            background: #444444;
            border-color: var(--primary-red);
            box-shadow: 0 3px 12px rgba(224, 26, 79, 0.6);
            transform: translateY(-2px);
        }

        /* Loader aprimorado */
        .loader {
            border-top-color: var(--primary-red);
            border-right-color: var(--primary-red);
            border-bottom-color: var(--primary-red);
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        #loader-text {
            color: var(--primary-red);
            text-shadow: 0 0 10px var(--primary-red);
            animation: pulse 1.5s infinite alternate;
        }
        @keyframes pulse {
            from { opacity: 1; }
            to { opacity: 0.7; }
        }


        /* Alerta customizado */
        .custom-alert {
            transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
            background-color: var(--primary-red);
            color: var(--light-text);
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(224, 26, 79, 0.7);
        }
        .custom-alert.show {
            transform: translateX(0);
            opacity: 1;
        }

        /* --- ESTILOS DE EXIBIÇÃO DE CARTAS OTIMIZADOS --- */
        .card-base {
            transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
            border-radius: 1rem;
            overflow: hidden;
            border: 3px solid #444;
            background-color: #1a1a1a;
            position: relative; 
            transform-style: preserve-3d;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.6);
            cursor: grab;
        }
        .card-base:hover {
            transform: scale(1.08) rotateZ(0.5deg);
            z-index: 20;
        }
        
        .rank-badge {
            position: absolute;
            top: 12px;
            left: 12px;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Orbitron', sans-serif;
            font-weight: 900;
            font-size: 28px;
            color: white;
            text-shadow: 0 0 10px rgba(0,0,0,0.9);
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            z-index: 10;
            border: 2px solid rgba(255,255,255,0.4);
            box-shadow: 0 0 10px rgba(0,0,0,0.7);
        }

        .card-image-overlay {
            background-image: linear-gradient(to top, rgba(0,0,0,0.95) 0%, transparent 60%), 
                              linear-gradient(to bottom, rgba(0,0,0,0.85) 0%, transparent 50%);
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 1rem;
        }

        .collection-card-image-wrapper {
            position: relative;
            width: 100%;
            height: 200px;
            overflow: hidden;
            border-radius: 1rem 1rem 0 0;
        }

        .collection-card-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            object-position: center;
            transition: transform 0.3s ease-in-out;
        }

        .card-base:hover .collection-card-image {
            transform: scale(1.05);
        }

        .collection-card-info-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to top, rgba(0,0,0,0.9) 0%, transparent 60%), 
                        linear-gradient(to bottom, rgba(0,0,0,0.7) 0%, transparent 50%);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 1rem;
        }

        .rank-badge-small {
            position: absolute;
            top: 12px;
            left: 12px;
            width: 38px;
            height: 38px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Orbitron', sans-serif;
            font-weight: 900;
            font-size: 20px;
            color: white;
            text-shadow: 0 0 10px rgba(0,0,0,0.9);
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            border: 2px solid rgba(255,255,255,0.4);
            box-shadow: 0 0 10px rgba(0,0,0,0.7);
            z-index: 10;
        }

        .card-text-shadow {
            text-shadow: 1px 1px 6px black, 0 0 12px black;
        }
        .card-flag-shadow {
             box-shadow: 0 0 6px black;
        }
        
        /* Efeito holográfico otimizado (só com CSS, ativado no hover) */
        @keyframes holographic-move {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        .holographic-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(110deg, transparent 30%, rgba(255, 255, 255, 0.2) 50%, transparent 70%);
            background-size: 300% 100%;
            opacity: 0;
            transition: opacity 0.4s ease;
            z-index: 3;
            pointer-events: none;
            border-radius: 1rem;
        }

        .card-base:hover .holographic-overlay, .deck-card-container:hover .holographic-overlay {
            opacity: 1;
            animation: holographic-move 4s infinite linear; /* Animação só roda no hover */
        }
        
        /* Animação de brilho que percorre a carta */
        @keyframes shine {
            0% { transform: translateX(-180%) skewX(-25deg); }
            100% { transform: translateX(180%) skewX(-25deg); }
        }
        
        /* Efeito de brilho aplicado com ::after para performance */
        .card-base::after {
            content: '';
            position: absolute;
            top: 0; left: 0; width: 50%; height: 100%;
            opacity: 0; z-index: 2;
            background: var(--shine-gradient);
            border-radius: 1rem;
        }
        
        /* Ativa a animação de brilho apenas no hover */
        .card-base:hover::after {
             opacity: var(--shine-opacity, 0.4);
             animation: shine var(--shine-duration, 8s) infinite linear;
        }

        /* --- Estilos de raridade otimizados --- */
        /* Removidas animações pulsantes. Foco em bordas e sombras estáticas no hover. */
        .rank-x.card-base { border-color: #333; background-color: #050505; }
        .rank-x.card-base:hover { box-shadow: 0 0 30px 6px rgba(120, 0, 255, 1), 0 0 18px 4px rgba(0, 255, 255, 1) inset; }
        .rank-x.card-base::after {
            --shine-gradient: linear-gradient(to right, rgba(120, 0, 255, 0) 0%, rgba(120, 0, 255, 0.8) 30%, rgba(0, 255, 255, 0.9) 50%, rgba(255, 255, 255, 0.8) 70%, rgba(120, 0, 255, 0) 100%);
            --shine-duration: 1.8s; --shine-opacity: 1;
        }

        .rank-r.card-base { border-color: #00FFFF; }
        .rank-r.card-base:hover { box-shadow: 0 0 40px 10px rgba(0, 255, 255, 1), 0 0 20px 6px rgba(255, 255, 255, 1) inset; }
        .rank-r.card-base::after {
            --shine-gradient: linear-gradient(to right, rgba(0, 255, 255, 0) 0%, rgba(0, 255, 255, 1) 25%, rgba(255, 0, 255, 1) 50%, rgba(255, 255, 0, 1) 75%, rgba(0, 255, 255, 0) 100%);
            --shine-duration: 2.5s; --shine-opacity: 1;
        }
        
        .rank-s.card-base { border-color: #FFD700; }
        .rank-s.card-base:hover { box-shadow: 0 0 35px 8px rgba(255, 215, 0, 1), 0 0 15px 4px rgba(255, 215, 0, 0.9) inset; }
        .rank-s.card-base::after { --shine-gradient: linear-gradient(to right, rgba(255, 215, 0, 0) 0%, rgba(255, 215, 0, 1) 50%, rgba(255, 215, 0, 0) 100%); --shine-duration: 3s; --shine-opacity: 0.9; }
        
        .rank-a.card-base { border-color: var(--primary-red); }
        .rank-a.card-base:hover { box-shadow: 0 0 25px 6px var(--primary-red); }
        .rank-a.card-base::after { --shine-gradient: linear-gradient(to right, rgba(224, 26, 79, 0) 0%, rgba(224, 26, 79, 0.8) 50%, rgba(224, 26, 79, 0) 100%); --shine-duration: 4s; --shine-opacity: 0.8; }
        
        .rank-b.card-base { border-color: #8e44ad; }
        .rank-b.card-base:hover { box-shadow: 0 0 20px 4px #8e44ad; }
        .rank-b.card-base::after { --shine-gradient: linear-gradient(to right, rgba(142, 68, 173, 0) 0%, rgba(142, 68, 173, 0.7) 50%, rgba(142, 68, 173, 0) 100%); --shine-duration: 5.5s; --shine-opacity: 0.7; }
        
        .rank-c.card-base { border-color: #3498db; }
        .rank-c.card-base:hover { box-shadow: 0 0 15px 3px #3498db; }
        .rank-c.card-base::after { --shine-gradient: linear-gradient(to right, rgba(52, 152, 219, 0) 0%, rgba(52, 152, 219, 0.6) 50%, rgba(52, 152, 219, 0) 100%); --shine-duration: 7s; --shine-opacity: 0.6; }
        
        .rank-d.card-base { border-color: #2ecc71; }
        .rank-d.card-base:hover { box-shadow: 0 0 12px 2px #2ecc71; }
        .rank-d.card-base::after { --shine-gradient: linear-gradient(to right, rgba(46, 204, 113, 0) 0%, rgba(46, 204, 113, 0.5) 50%, rgba(46, 204, 113, 0) 100%); --shine-duration: 8.5s; --shine-opacity: 0.5; }

        .selected-indicator {
            position: absolute;
            top: 15px;
            left: 65px;
            background-color: rgba(255, 215, 0, 0.9);
            color: #1a1a1a;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            padding: 5px 12px;
            border-radius: 6px;
            font-size: 12px;
            z-index: 15;
            pointer-events: none;
            text-transform: uppercase;
            letter-spacing: 0.75px;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
        }

        [draggable="true"].dragging {
            opacity: 0.2;
            cursor: grabbing;
        }

        .card-slot {
            background-color: rgba(0, 0, 0, 0.4);
            border: 3px dashed var(--border-strong);
            transition: all 0.3s ease;
            min-height: 180px;
            height: 100%;
            border-radius: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: inset 0 0 15px rgba(0,0,0,0.6);
        }
        .card-slot.drag-over {
            background-color: rgba(224, 26, 79, 0.2);
            border-color: var(--primary-red);
            box-shadow: inset 0 0 20px rgba(224, 26, 79, 0.4);
        }
        .card-base.drag-over {
             border-color: var(--primary-red);
             box-shadow: 0 0 25px var(--primary-red);
        }

        /* --- NOVOS ESTILOS DE FILTRO --- */
        .filter-input, .filter-select {
            background-color: rgba(10, 10, 10, 0.8);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            padding: 0.5rem 0.75rem;
            color: var(--text-light);
            transition: border-color 0.3s, box-shadow 0.3s;
        }
        .filter-input:focus, .filter-select:focus {
            outline: none;
            border-color: var(--primary-red);
            box-shadow: 0 0 10px rgba(224, 26, 79, 0.5);
        }
        .filter-label { 
            font-weight: 500; 
            color: #a0aec0; 
            margin-bottom: 0.25rem; 
            display: block; 
            font-size: 0.875rem;
        }
        .filter-button {
            background: var(--primary-red);
            border: none;
            color: white;
            padding: 0.6rem 1.2rem;
            border-radius: 0.5rem;
            font-weight: 700;
            transition: background-color 0.3s;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
        }
        .filter-button:hover { background-color: #c01040; }


        .deck-card-container {
            perspective: 1000px;
            cursor: grab;
        }

        .deck-card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }

        .deck-card-container:hover .deck-card-inner {
            transform: rotateY(180deg);
        }

        .card-front, .card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            border-radius: 1rem;
            overflow: hidden;
            border: 3px solid #444;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.6);
        }

        .card-front {
            background-color: #1a1a1a;
        }

        .card-back {
            background-color: var(--dark-bg);
            transform: rotateY(180deg);
            padding: 1rem;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            box-shadow: inset 0 0 15px rgba(0,0,0,0.7);
        }
        .card-back h3 {
            font-size: 90%;
            margin-bottom: 0.75rem;
            text-shadow: var(--text-shadow-strong);
        }
        .card-back .grid {
            width: 110%;
            max-width: 250px;
        }
        .card-back .grid > div {
            font-size: 90%;
            padding: 0.25rem 0;
        }
        .card-back .font-bold {
            color: var(--primary-red);
        }

        .deck-card-container .rank-badge {
             width: 45px;
             height: 45px;
             font-size: 26px;
             top: 10px;
             left: 10px;
        }

        @keyframes card-drop-effect {
            0% { transform: scale(1); filter: brightness(1); }
            50% { transform: scale(1.05); filter: brightness(1.75); }
            100% { transform: scale(1); filter: brightness(1); }
        }

        .card-dropped .deck-card-inner {
            animation: card-drop-effect 0.4s ease-out;
        }

        .particle {
            position: fixed;
            border-radius: 50%;
            pointer-events: none;
            z-index: 100;
            animation: fly-out forwards;
        }

        @keyframes fly-out {
            0% {
                transform: translate(0, 0) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(var(--x), var(--y)) scale(0);
                opacity: 0;
            }
        }
        
        @media (max-width: 1023px) { /* Tailind CSS `lg` breakpoint */
            body {
                background-attachment: scroll;
            }
            .header-panel {
                padding: 1rem;
                border-radius: 0;
            }
            .info-box {
                padding: 0.4rem 0.8rem;
                font-size: 0.9rem;
            }
            main {
                padding: 1rem;
            }
            h2 {
                font-size: 2.2rem;
            }
            .rank-badge {
                width: 38px;
                height: 38px;
                font-size: 22px;
                top: 8px;
                left: 8px;
            }
            .rank-badge-small {
                width: 30px;
                height: 30px;
                font-size: 16px;
                top: 8px;
                left: 8px;
            }
            .selected-indicator {
                top: 10px;
                left: 50px;
                padding: 3px 8px;
                font-size: 10px;
            }
            .card-text-shadow {
                text-shadow: 1px 1px 4px black;
            }
            .card-image-overlay {
                padding: 0.75rem;
            }
            .collection-card-info-overlay {
                padding: 0.75rem;
            }
            .card-back h3 {
                font-size: 90%;
            }
            .card-back .grid > div {
                font-size: 90%;
            }
            .collection-card-image-wrapper {
                height: 150px;
            }
        }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <!-- Loader de Carregamento -->
    <div id="loader" class="fixed inset-0 bg-black bg-opacity-95 flex flex-col items-center justify-center z-50">
        <div class="loader ease-linear rounded-full border-8 border-t-8 border-gray-500 h-28 w-28"></div>
        <p id="loader-text" class="mt-8 text-2xl font-orbitron">A procurar os seus carros...</p>
    </div>

    <!-- Alerta Customizado (substitui alert() e confirm()) -->
    <div id="custom-alert" class="custom-alert fixed top-5 right-0 text-white py-3 px-5 rounded-l-lg shadow-lg z-50 opacity-0 transform translate-x-full">
        <p id="custom-alert-message" class="font-bold"></p>
    </div>

    <!-- Container Principal da Aplicação -->
    <div id="app-container" class="hidden w-full min-h-screen flex flex-col">
        
        <!-- Header (Top Bar) - Será preenchido pelo menu.js -->
        <header id="main-header" class="w-full sticky top-0 z-40"></header>

        <!-- Conteúdo Principal -->
        <main class="flex-grow p-6 md:p-10 container mx-auto">
            
            <section class="mb-12 mt-8">
                <h2 class="font-orbitron text-3xl md:text-4xl font-bold text-white mb-8" style="text-shadow: var(--glow-effect);">O SEU DECK ATIVO</h2>
                <div id="deck-container" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-3 xl:grid-cols-4 2xl:grid-cols-5 gap-8">
                </div>
            </section>

            <section class="mb-8 glass-panel p-6">
                <h3 class="font-orbitron text-2xl font-bold text-white mb-6" style="text-shadow: var(--text-shadow-strong);">FILTRAR CARTAS</h3>
                <div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-9 gap-4 items-end">
                    <div class="xl:col-span-2">
                        <label for="search-nome" class="filter-label">Nome</label>
                        <input type="text" id="search-nome" placeholder="Pesquisar..." class="filter-input w-full">
                    </div>
                    <div>
                        <label for="filter-montadora" class="filter-label">Marca</label>
                        <select id="filter-montadora" class="filter-select w-full"></select>
                    </div>
                    <div>
                        <label class="filter-label">Ano</label>
                        <div class="flex gap-2">
                            <input type="number" id="filter-year-min" placeholder="Desde" class="filter-input w-full">
                            <input type="number" id="filter-year-max" placeholder="Até" class="filter-input w-full">
                        </div>
                    </div>
                    <div>
                        <label for="filter-tracao" class="filter-label">Tração</label>
                        <select id="filter-tracao" class="filter-select w-full"></select>
                    </div>
                    <div>
                        <label for="filter-altura" class="filter-label">Altura</label>
                        <select id="filter-altura" class="filter-select w-full"></select>
                    </div>
                    <div>
                        <label for="filter-pneus" class="filter-label">Pneus</label>
                        <select id="filter-pneus" class="filter-select w-full"></select>
                    </div>
                    <div class="md:col-span-1 xl:col-span-1">
                         <label class="filter-label">Classe</label>
                         <div id="filter-classes" class="grid grid-cols-3 sm:grid-cols-4 lg:grid-cols-5 gap-2 text-sm"></div>
                    </div>
                    <div class="w-full">
                       <button id="clear-filters-button" class="filter-button w-full">Limpar</button>
                    </div>
                </div>
            </section>

            <section id="collection-drop-zone" class="min-h-[300px] p-6 border-2 border-dashed border-gray-700 rounded-xl flex flex-col items-center justify-center bg-black/40 shadow-inner">
                <h2 class="font-orbitron text-3xl md:text-4xl font-bold text-white mb-8" style="text-shadow: var(--glow-effect);">AS MINHAS CARTAS</h2>
                <p class="text-gray-400 text-lg mb-6 text-center">Arraste cartas do seu deck para aqui para as remover, ou arraste cartas da sua coleção para os espaços do deck.</p>
                <div id="collection-container" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-3 xl:grid-cols-4 gap-8 w-full">
                </div>
            </section>
        </main>
    </div>

    <script type="module">
        // Importa as instâncias prontas do seu novo arquivo central
        import { auth, db } from './firebase.js';

        // Importa apenas as FUNÇÕES que você vai usar nesta página
        import { onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { ref, get, update } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-database.js";
        
        // Importa seus módulos locais
        import { cards as localCardsDatabase } from './cards.js';
        import { createHeader } from './menu.js';

        // Referências aos elementos do DOM
        const loader = document.getElementById('loader');
        const appContainer = document.getElementById('app-container');
        const deckContainer = document.getElementById('deck-container');
        const collectionContainer = document.getElementById('collection-container');
        const collectionDropZone = document.getElementById('collection-drop-zone');
        const searchInput = document.getElementById('search-nome');
        const montadoraFilter = document.getElementById('filter-montadora');
        const yearMinFilter = document.getElementById('filter-year-min');
        const yearMaxFilter = document.getElementById('filter-year-max');
        const classesContainer = document.getElementById('filter-classes');
        const tracaoFilter = document.getElementById('filter-tracao');
        const alturaFilter = document.getElementById('filter-altura');
        const pneusFilter = document.getElementById('filter-pneus');
        const clearFiltersButton = document.getElementById('clear-filters-button');
        const mainHeader = document.getElementById('main-header'); // Referência para o novo header

        // Variáveis de estado da aplicação
        let currentUser = null;
        let ownedCardIds = [];
        let activeDeckIds = [];
        let scrollInterval = null;
        let draggedGhost = null;
        let offsetX = 0;
        let offsetY = 0;
        let latestMouseX = 0;
        let latestMouseY = 0;
        let animationFrameId = null;

        /**
         * Mostra um alerta customizado na tela.
         * @param {string} message - A mensagem a ser exibida.
         */
        function showCustomAlert(message) {
            const alertElement = document.getElementById('custom-alert');
            const messageElement = document.getElementById('custom-alert-message');
            messageElement.textContent = message;
            alertElement.classList.add('show');
            setTimeout(() => {
                alertElement.classList.remove('show');
            }, 3000);
        }

        /**
         * Retorna a cor do rank com base na classe da carta.
         * @param {string} rank - A classe da carta.
         * @returns {string} A cor hexadecimal.
         */
        function getRankColor(rank) {
            const colors = {
                'X': '#000000', 'R': '#00FFFF', 'S+': '#FFD700', 'S': '#FFD700', 'A': '#E01A4F',
                'B': '#8e44ad', 'C': '#3498db', 'D': '#2ecc71', 'E': '#95a5a6'
            };
            return colors[rank] || '#7F8C8D';
        }

        /**
         * Cria um elemento de carta para a coleção.
         * @param {string} cardId - O ID da carta.
         * @returns {HTMLElement|null} O elemento da carta.
         */
        function createCollectionCardElement(cardId) {
            const cardData = localCardsDatabase[cardId];
            if (!cardData) return null;

            const cardElement = document.createElement('div');
            cardElement.className = `card-base rank-${cardData.classe.toLowerCase().replace('+', '')}`;
            cardElement.setAttribute('draggable', true);
            cardElement.dataset.cardId = cardId;

            cardElement.innerHTML = `
                <div class="collection-card-image-wrapper">
                    <img src="${cardData.imagem}" alt="${cardData.nome}" class="collection-card-image">
                    <div class="rank-badge-small" style="background-color: ${getRankColor(cardData.classe)};">${cardData.classe.replace('+', '⁺')}</div>
                    <div class="collection-card-info-overlay">
                        <div class="flex justify-between items-start w-full">
                            <img src="${cardData.logo}" alt="${cardData.montadora}" class="h-5 mt-12" style="filter: drop-shadow(0 0 2px black);">
                            <div class="text-right">
                                <div class="font-bold text-base font-orbitron card-text-shadow">${cardData.ano}</div>
                                <img src="${cardData.bandeira}" alt="${cardData.pais}" class="h-5 w-8 object-cover rounded-sm ml-auto mt-1 card-flag-shadow">
                            </div>
                        </div>
                        <h3 class="font-bold text-lg md:text-xl font-orbitron leading-tight card-text-shadow">${cardData.nome}</h3>
                    </div>
                </div>
                <div class="p-3 bg-[#181818] grid grid-cols-3 gap-2 text-center text-sm">
                    <div><span class="font-bold block">${cardData.velocidade}</span> VEL. MÁX.</div>
                    <div><span class="font-bold block">${cardData.aceleracao}s</span> 0-100</div>
                    <div><span class="font-bold block">${cardData.direcao}</span> DIREÇÃO</div>
                    <div><span class="font-bold block">${cardData.altura}</span> ALTURA</div>
                    <div><span class="font-bold block">${cardData.pneus}</span> PNEUS</div>
                    <div><span class="font-bold block">${cardData.tracao}</span> TRAÇÃO</div>
                </div>
            `;

            // Otimização: Efeito holográfico só com CSS, sem necessidade de JS aqui
            if (['X', 'R', 'S+', 'S', 'A', 'B'].includes(cardData.classe)) {
                const overlay = document.createElement('div');
                overlay.className = 'holographic-overlay';
                cardElement.querySelector('.collection-card-image-wrapper').prepend(overlay);
            }

            cardElement.addEventListener('dragstart', handleDragStart);
            cardElement.addEventListener('dragend', handleDragEnd);
            return cardElement;
        }

        /**
         * Cria um slot de carta para o deck.
         * @param {number} index - O índice do slot.
         * @param {string|null} cardId - O ID da carta no slot.
         * @returns {HTMLElement} O elemento do slot.
         */
        function createDeckSlotElement(index, cardId = null) {
            const slotWrapper = document.createElement('div');
            slotWrapper.dataset.slotIndex = index;
            const cardData = cardId ? localCardsDatabase[cardId] : null;

            if (cardData) {
                slotWrapper.className = `deck-card-container aspect-[16/10]`;
                slotWrapper.setAttribute('draggable', true);
                slotWrapper.dataset.cardId = cardId;
                slotWrapper.innerHTML = `
                    <div class="deck-card-inner">
                        <div class="card-front card-base rank-${cardData.classe.toLowerCase().replace('+', '')}">
                            <div class="relative w-full h-full bg-cover bg-center" style="background-image: url('${cardData.imagem}')">
                                <div class="rank-badge" style="background-color: ${getRankColor(cardData.classe)};">${cardData.classe.replace('+', '⁺')}</div>
                                <div class="card-image-overlay">
                                    <div class="flex justify-between items-start">
                                        <img src="${cardData.logo}" alt="${cardData.montadora}" class="h-5 mt-12" style="filter: drop-shadow(0 0 2px black);">
                                        <div class="text-right">
                                            <div class="font-bold text-lg font-orbitron card-text-shadow">${cardData.ano}</div>
                                            <img src="${cardData.bandeira}" alt="${cardData.pais}" class="h-5 w-8 object-cover rounded-sm ml-auto mt-1 card-flag-shadow">
                                        </div>
                                    </div>
                                    <h3 class="font-bold text-xl font-orbitron leading-tight card-text-shadow">${cardData.nome}</h3>
                                </div>
                            </div>
                        </div>
                        <div class="card-back">
                            <h3 class="font-bold font-orbitron mb-1 text-center">${cardData.nome}</h3>
                            <div class="grid grid-cols-2 gap-x-4 gap-y-1 text-xs">
                                <div class="flex justify-between"><span>Vel. Máx:</span> <span class="font-bold">${cardData.velocidade}</span></div>
                                <div class="flex justify-between"><span>0-100km/h:</span> <span class="font-bold">${cardData.aceleracao}s</span></div>
                                <div class="flex justify-between"><span>Direção:</span> <span class="font-bold">${cardData.direcao}</span></div>
                                <div class="flex justify-between"><span>Altura:</span> <span class="font-bold">${cardData.altura}</span></div>
                                <div class="flex justify-between"><span>Pneus:</span> <span class="font-bold">${cardData.pneus}</span></div>
                                <div class="flex justify-between"><span>Tração:</span> <span class="font-bold">${cardData.tracao}</span></div>
                                <div class="flex justify-between"><span>País:</span> <span class="font-bold">${cardData.pais}</span></div>
                                <div class="flex justify-between"><span>Montadora:</span> <span class="font-bold">${cardData.montadora}</span></div>
                            </div>
                        </div>
                    </div>`;

                if (['X', 'R', 'S+', 'S', 'A', 'B'].includes(cardData.classe)) {
                    const overlay = document.createElement('div');
                    overlay.className = 'holographic-overlay';
                    slotWrapper.querySelector('.card-front .relative').prepend(overlay);
                }
                slotWrapper.addEventListener('dragstart', handleDragStart);
                slotWrapper.addEventListener('dragend', handleDragEnd);
            } else {
                slotWrapper.className = 'card-slot aspect-[16/10]';
                slotWrapper.innerHTML = `<span class="text-gray-500 text-sm p-4 text-center font-orbitron">ARRASTE UMA CARTA AQUI</span>`;
            }

            slotWrapper.addEventListener('dragover', handleDragOver);
            slotWrapper.addEventListener('dragleave', handleDragLeave);
            slotWrapper.addEventListener('drop', handleDropOnDeck);
            return slotWrapper;
        }

        /**
         * Renderiza a coleção de cartas filtradas.
         * @param {Array<string>} filteredIds - IDs das cartas a renderizar.
         */
        function renderCollection(filteredIds) {
            collectionContainer.innerHTML = '';
            filteredIds.forEach(cardId => {
                const cardElement = createCollectionCardElement(cardId);
                if (cardElement) {
                    if (activeDeckIds.includes(cardId)) {
                        const selectedIndicator = document.createElement('div');
                        selectedIndicator.className = 'selected-indicator';
                        selectedIndicator.textContent = 'Selecionado';
                        cardElement.appendChild(selectedIndicator);
                    }
                    collectionContainer.appendChild(cardElement);
                }
            });
        }
        
        /**
         * Renderiza o deck ativo.
         * @param {number} [animatedIndex=-1] - Índice da carta a animar.
         */
        function renderDeck(animatedIndex = -1) {
            deckContainer.innerHTML = '';
            for (let i = 0; i < 5; i++) {
                const cardId = activeDeckIds[i] || null;
                const slotElement = createDeckSlotElement(i, cardId);
                deckContainer.appendChild(slotElement);
                if (i === animatedIndex && cardId) {
                    setTimeout(() => {
                        slotElement.classList.add('card-dropped');
                        slotElement.addEventListener('animationend', () => slotElement.classList.remove('card-dropped'), { once: true });
                    }, 0);
                }
            }
        }
        
        function debounce(func, delay = 300) {
            let timeout;
            return (...args) => {
                clearTimeout(timeout);
                timeout = setTimeout(() => { func.apply(this, args); }, delay);
            };
        }
        const debouncedFilter = debounce(applyFilters);


        /**
         * Aplica os filtros atuais e re-renderiza a coleção.
         */
        function applyFilters() {
            const searchTerm = searchInput.value.toLowerCase();
            const selectedMontadora = montadoraFilter.value;
            const yearMin = parseInt(yearMinFilter.value) || 0;
            const yearMax = parseInt(yearMaxFilter.value) || 9999;
            const selectedTracao = tracaoFilter.value;
            const selectedAltura = alturaFilter.value;
            const selectedPneus = pneusFilter.value;
            const selectedClasses = [...classesContainer.querySelectorAll('input:checked')].map(el => el.value);
            const rarityOrder = ['X','R','S+', 'S', 'A', 'B', 'C', 'D', 'E'];

            const sortedOwnedCardIds = [...ownedCardIds].sort((a, b) => {
                const aInDeck = activeDeckIds.includes(a);
                const bInDeck = activeDeckIds.includes(b);
                if (aInDeck && !bInDeck) return -1;
                if (!aInDeck && bInDeck) return 1;
                const cardA = localCardsDatabase[a];
                const cardB = localCardsDatabase[b];
                if (!cardA || !cardB) return 0;
                return rarityOrder.indexOf(cardA.classe) - rarityOrder.indexOf(cardB.classe);
            });

            const filtered = sortedOwnedCardIds.filter(cardId => {
                const card = localCardsDatabase[cardId];
                if (!card) return false;
                return card.nome.toLowerCase().includes(searchTerm) &&
                       (!selectedMontadora || card.montadora === selectedMontadora) &&
                       (card.ano >= yearMin && card.ano <= yearMax) &&
                       (!selectedTracao || card.tracao === selectedTracao) &&
                       (!selectedAltura || card.altura === selectedAltura) &&
                       (!selectedPneus || card.pneus === selectedPneus) &&
                       (selectedClasses.length > 0 ? selectedClasses.includes(card.classe) : true);
            });
            renderCollection(filtered);
        }

        /**
         * Popula os menus de filtro com opções únicas.
         */
        function populateFilters() {
            const ownedCardsData = ownedCardIds.map(id => localCardsDatabase[id]).filter(Boolean);
            const classes = ['X', 'R', 'S+', 'S', 'A', 'B', 'C', 'D', 'E'];
            
            const populateSelect = (select, options, placeholder) => {
                select.innerHTML = `<option value="">${placeholder}</option>`;
                options.forEach(opt => select.innerHTML += `<option value="${opt}">${opt}</option>`);
            };

            populateSelect(montadoraFilter, [...new Set(ownedCardsData.map(c => c.montadora))].sort(), 'Todas');
            populateSelect(tracaoFilter, [...new Set(ownedCardsData.map(c => c.tracao))].sort(), 'Todas');
            populateSelect(alturaFilter, [...new Set(ownedCardsData.map(c => c.altura))].sort(), 'Todas');
            populateSelect(pneusFilter, [...new Set(ownedCardsData.map(c => c.pneus))].sort(), 'Todos');

            classesContainer.innerHTML = '';
            classes.forEach(c => {
                classesContainer.innerHTML += `
                    <div class="flex items-center">
                        <input type="checkbox" id="class-${c}" value="${c}" class="filter-checkbox accent-red-500 w-4 h-4" checked>
                        <label for="class-${c}" class="ml-2">${c}</label>
                    </div>`;
            });
        }

        /**
         * Guarda o deck no Firebase.
         * @param {Array<string|null>} newDeck - O novo array do deck.
         * @param {number} [animatedIndex=-1] - Índice da carta a animar.
         */
        async function saveDeckToFirebase(newDeck, animatedIndex = -1) {
            if (!currentUser) return;
            try {
                await update(ref(db, 'users/' + currentUser.uid), { deck: newDeck });
                activeDeckIds = newDeck;
                renderDeck(animatedIndex);
                applyFilters();
            } catch (error) {
                console.error("Erro ao guardar o deck:", error);
                showCustomAlert("Não foi possível guardar o seu deck.");
            }
        }

        // Funções de Drag and Drop
        function updateGhostPosition() {
            if (!draggedGhost) return;
            draggedGhost.style.transform = `translate3d(${latestMouseX - offsetX}px, ${latestMouseY - offsetY}px, 0) rotateZ(8deg) scale(0.7)`;
            animationFrameId = null;
        }

        function handleDragStart(e) {
            const originalElement = e.currentTarget;
            const rect = originalElement.getBoundingClientRect();
            offsetX = e.clientX - rect.left;
            offsetY = e.clientY - rect.top;
            draggedGhost = document.createElement('div');
            // Clona o elemento visualmente, mas não os event listeners
            const visualClone = originalElement.querySelector('.card-base') || originalElement;
            draggedGhost.className = visualClone.className;
            draggedGhost.innerHTML = visualClone.innerHTML;
            const holo = draggedGhost.querySelector('.holographic-overlay');
            if (holo) holo.remove();
            
            Object.assign(draggedGhost.style, {
                position: 'fixed', zIndex: '1000', pointerEvents: 'none',
                width: `${rect.width}px`, height: `${rect.height}px`, left: '0px', top: '0px',
                transform: `translate3d(${e.clientX - offsetX}px, ${e.clientY - offsetY}px, 0) rotateZ(8deg) scale(0.7)`
            });
            document.body.appendChild(draggedGhost);
            setTimeout(() => originalElement.classList.add('dragging'), 0);
            e.dataTransfer.setDragImage(new Image(), 0, 0);
            e.dataTransfer.setData('text/plain', originalElement.dataset.cardId);
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleDragEnd(e) {
            e.currentTarget.classList.remove('dragging');
            if (draggedGhost) {
                document.body.removeChild(draggedGhost);
                draggedGhost = null;
            }
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
            clearInterval(scrollInterval);
            scrollInterval = null;
        }

        function handleDragOver(e) {
            e.preventDefault();
            document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
            const target = e.target.closest('[data-slot-index], .card-base, #collection-drop-zone');
            if (target) target.classList.add('drag-over');
        }

        function handleDragLeave(e) {
            const target = e.target.closest('.drag-over');
            if (target) target.classList.remove('drag-over');
        }

        document.addEventListener('dragover', (e) => {
            e.preventDefault();
            if (draggedGhost) {
                latestMouseX = e.clientX;
                latestMouseY = e.clientY;
                if (!animationFrameId) animationFrameId = requestAnimationFrame(updateGhostPosition);
            }
            const scrollZone = window.innerHeight * 0.15;
            if (e.clientY < scrollZone) {
                if (!scrollInterval) scrollInterval = setInterval(() => window.scrollBy(0, -100), 50);
            } else if (e.clientY > window.innerHeight - scrollZone) {
                if (!scrollInterval) scrollInterval = setInterval(() => window.scrollBy(0, 100), 50);
            } else {
                clearInterval(scrollInterval);
                scrollInterval = null;
            }
        });

        function createExplosion(x, y, color, rank) {
            // Otimização: Reduzido o número de partículas
            const particleCount = rank === 'S' ? 30 : rank === 'A' ? 20 : 15;
            const baseDistance = rank === 'S' ? 150 : rank === 'A' ? 110 : 80;
            for (let i = 0; i < particleCount; i++) {
                const p = document.createElement('div');
                p.className = 'particle';
                document.body.appendChild(p);
                const angle = Math.random() * Math.PI * 2, dist = Math.random() * baseDistance + 40;
                Object.assign(p.style, {
                    width: `${Math.random() * 6 + 4}px`, height: `${Math.random() * 6 + 4}px`,
                    animationDuration: `${Math.random() * 0.5 + 0.7}s`, background: color,
                    left: `${x}px`, top: `${y}px`
                });
                p.style.setProperty('--x', `${Math.cos(angle) * dist}px`);
                p.style.setProperty('--y', `${Math.sin(angle) * dist}px`);
                p.addEventListener('animationend', () => p.remove());
            }
        }

        async function handleDropOnDeck(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('drag-over');
            const draggedCardId = e.dataTransfer.getData('text/plain');
            const targetSlotIndex = parseInt(e.currentTarget.dataset.slotIndex);
            if (!draggedCardId || isNaN(targetSlotIndex)) return;

            const cardData = localCardsDatabase[draggedCardId];
            if (cardData) createExplosion(e.clientX, e.clientY, getRankColor(cardData.classe), cardData.classe.replace('+', ''));

            const newDeck = [...activeDeckIds];
            const oldIndexInDeck = activeDeckIds.indexOf(draggedCardId);
            if (oldIndexInDeck > -1) newDeck[oldIndexInDeck] = null;
            const cardInTargetSlot = newDeck[targetSlotIndex];
            newDeck[targetSlotIndex] = draggedCardId;
            if (cardInTargetSlot && oldIndexInDeck > -1) newDeck[oldIndexInDeck] = cardInTargetSlot;
            const finalDeck = Array.from({ length: 5 }, (_, i) => newDeck[i] || null);
            await saveDeckToFirebase(finalDeck, targetSlotIndex);
        }

        async function handleDropOnCollection(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('drag-over');
            const draggedCardId = e.dataTransfer.getData('text/plain');
            if (activeDeckIds.includes(draggedCardId)) {
                if (activeDeckIds.filter(id => id !== null).length <= 1) {
                    showCustomAlert("O deck não pode ficar vazio! Mantenha pelo menos uma carta.");
                    return;
                }
                const newDeck = activeDeckIds.map(id => id === draggedCardId ? null : id);
                await saveDeckToFirebase(newDeck);
            }
        }

        // Listeners dos filtros e da zona de drop
        searchInput.addEventListener('input', debouncedFilter);
        montadoraFilter.addEventListener('change', applyFilters);
        tracaoFilter.addEventListener('change', applyFilters);
        alturaFilter.addEventListener('change', applyFilters);
        pneusFilter.addEventListener('change', applyFilters);
        [yearMinFilter, yearMaxFilter].forEach(el => el.addEventListener('input', debouncedFilter));
        classesContainer.addEventListener('change', applyFilters);

        clearFiltersButton.addEventListener('click', () => {
            searchInput.value = '';
            montadoraFilter.value = '';
            tracaoFilter.value = '';
            alturaFilter.value = '';
            pneusFilter.value = '';
            yearMinFilter.value = '';
            yearMaxFilter.value = '';
            classesContainer.querySelectorAll('input').forEach(el => el.checked = true);
            applyFilters();
        });
        collectionDropZone.addEventListener('dragover', handleDragOver);
        collectionDropZone.addEventListener('dragleave', handleDragLeave);
        collectionDropZone.addEventListener('drop', handleDropOnCollection);

        // Lógica principal de autenticação e carregamento de dados
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                currentUser = user;
                try {
                    const snapshot = await get(ref(db, 'users/' + user.uid));
                    if (snapshot.exists()) {
                        const userData = snapshot.val();
                        
                        // Cria o header dinamicamente
                        createHeader(auth, userData, mainHeader, 'garagem');

                        ownedCardIds = userData.cartas || [];
                        activeDeckIds = userData.deck || Array(5).fill(null);
                        if (activeDeckIds.length < 5) activeDeckIds.push(...Array(5 - activeDeckIds.length).fill(null));

                        if (activeDeckIds.every(id => id === null) && ownedCardIds.length > 0) {
                            const initialDeck = Array(5).fill(null);
                            initialDeck[0] = ownedCardIds[0];
                            await saveDeckToFirebase(initialDeck);
                        } else {
                            renderDeck();
                        }

                        populateFilters();
                        applyFilters();

                        appContainer.classList.remove('hidden');
                        loader.classList.add('hidden');
                    } else {
                        console.error("Documento do utilizador não encontrado. A forçar logout.");
                        await signOut(auth);
                    }
                } catch (error) {
                    console.error("Erro ao procurar dados do utilizador:", error);
                    await signOut(auth);
                }
            } else {
                window.location.href = 'index.html';
            }
        });
    </script>
</body>
</html>
